// 题目描述
// 现给定一个正整数数组 nums，其按照时间顺序记录了数个同类任务的完成时长（单位为周），为了更准确评估该类任务的工作量，现做如下分析，找出每个任务的前面、比当前任务完成时长短的邻近时长，如果无法找到则记为 -1。将这些邻近时长记录成一个新数组并返回。

// 示例 1：
// 输入： nums = [1,6,4,10,2,5]
// 输出：[-1,1,1,4,1,2]
// 解释：第一个任务时长记录（1）左边没有记录，返回-1。第二个任务时长记录（6）左边只有一个比该时长更短的任务时长（1），所以返回1。
// 第四个任务时长记录（10）左边有三个比该时长更短的时长记录（1，6，4），所以返回最邻近的4。
// 示例 2：
// 输入：nums = [ 2, 4, 1, 3, 6]
// 输出：[ -1, 2, -1, 1, 3 ]
// 解释：第三个任务时长记录（1）左边没有比该时长更短的时长记录，（左边时长记录2，4均比1长），故返回-1。
// 限制：
// 1 <= nums 的长度 <= 100000
// 1 <= nums[i] <= 100000
// 输入
// 正整数数组 nums
// 输出
// 邻近时长新数组
// 样例
// 输入样例 1
// 1 6 4 10 2 5
// 输出样例 1
// -1 1 1 4 1 2 
// 输入样例 2 
// 2 4 1 3 6
// 输出样例 2
// -1 2 -1 1 3 

#include<bits/stdc++.h>

using namespace std;

int main(){
    vector<int> a;
    vector<int> ans;
    int n ;
    cin >> n;
    int t ;
    for(int i = 0 ; i < n ;i++){
        cin >> t;
        a.push_back(t);
    } 
    ans.push_back(-1);
    for(int i = 1 ; i < n ; i++){
        for(int j = i - 1; j >= 0 ; j--){
            if(a[j] < a[i]){
                ans.push_back(a[j]);
                break;
            }
            if(j==0) ans.push_back(-1);
        }
    }
    for(int t : ans){
        cout << t << " ";
    }
    return 0;
}